# 【前端】从零到一搭建一个完整的脚手架

[![冰码达](https://picx.zhimg.com/v2-672459de7e45999e200025315940ba06_l.jpg?source=32738c0c&needBackground=1)](//www.zhihu.com/people/bing-sui)

[冰码达](//www.zhihu.com/people/bing-sui)

[​![](https://pic1.zhimg.com/v2-2ddc5cc683982648f6f123616fb4ec09_l.png?source=32738c0c)](https://www.zhihu.com/question/48510028)

互联网行业 前端开发工程师

48 人赞同了该文章

网上关于如何搭建脚手架已经有很多文章了，但是对于我个人来讲，很多都讲的不够细致，突然就抛出一堆代码，很难去完全理解这些是做什么的，我后续想修改自己的东西感觉很吃力，还有就是现在2024年了，很多文章里面的代码都不能运行了，所以自己整理了这篇文章，内容有点长，但是对于入门级的自己来说收获很大。

## 为什么要搭建脚手架

我相信有很多同学都有过想要搭建一个脚手架的想法，但是想想直接复制过来改改也可以，就懒得去搞了，然后就没有然后了。或者有的同学认为已经有脚手架可以用了，比如我们常用的[vue-cli](https://zhida.zhihu.com/search?content_id=242068124&content_type=Article&match_order=1&q=vue-cli&zd_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ6aGlkYV9zZXJ2ZXIiLCJleHAiOjE3NjUyODM5NzcsInEiOiJ2dWUtY2xpIiwiemhpZGFfc291cmNlIjoiZW50aXR5IiwiY29udGVudF9pZCI6MjQyMDY4MTI0LCJjb250ZW50X3R5cGUiOiJBcnRpY2xlIiwibWF0Y2hfb3JkZXIiOjEsInpkX3Rva2VuIjpudWxsfQ.6OeV_aXsHfrvYMXfEPwfvGeJoL5Bz-PLgBfnls5DJ2k&zhida_source=entity)，[create-react-app](https://zhida.zhihu.com/search?content_id=242068124&content_type=Article&match_order=1&q=create-react-app&zd_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ6aGlkYV9zZXJ2ZXIiLCJleHAiOjE3NjUyODM5NzcsInEiOiJjcmVhdGUtcmVhY3QtYXBwIiwiemhpZGFfc291cmNlIjoiZW50aXR5IiwiY29udGVudF9pZCI6MjQyMDY4MTI0LCJjb250ZW50X3R5cGUiOiJBcnRpY2xlIiwibWF0Y2hfb3JkZXIiOjEsInpkX3Rva2VuIjpudWxsfQ.YNCDa0RXs9jwffkcb6BUsiOQZiXFX9WGRsue89rpdXE&zhida_source=entity)。

但是在我们不断的开发中，我们自己的不同项目肯定有一些公共东西是需要你在不同项目之间拷来拷去的。比如对axios的封装，换肤等功能。我们自己的项目自己去拷贝的话还好，偶尔会出现漏掉的情况，导致需要花时间去排错，那如果有新的同事入职呢。

脚手架可以给我们提供一个规范化的模板，避免掉一些低级的错误，节省掉我们重复性工作的时间。所以我推荐大家都搞一个属于自己的团队的脚手架，这是一劳永逸的事情。

## 开始搭建

### 初始化脚手架项目

1、首先我们打开一个空白的文件夹，执行命令

```text
npm init
```

2、新建 bin/index.js 文件，index.js 内容如下

```text
#! /usr/bin/env node
// 我们以下的所有console.log都是为了方便验证我们的操作是否成功，脚手架搭建成功后大家可以根据自己的需求进行删除
console.log('start cli');
```

在开发npm包时，入口文件需要在文件头部添加#! /usr/bin/env node，否则会报错No such file or directory

3、然后我们在生成的 paskage.json 文件中添加

```text
// package.json
{
  ...
  "name": "my-cli",
  "bin": "bin/index.js",
  ...
}
```

4、为了方便我们本地测试，我们执行一下

```text
// 可以将我们的my-cli链接到本地，--force是为了覆盖我们原有的指令
npm link --force
```

![](https://pica.zhimg.com/v2-d45176215fe6be473c90e57df4fffaf0_1440w.jpg)

npm link --force 成功输出

5、运行 my-cli 验证一下，成功打印 start cli 即可，如下图所示：

![](https://pic1.zhimg.com/v2-d62d21d1828889f5d107b675acb6282c_1440w.jpg)

### 添加脚手架操作

首先我们先想明白第一步我们需要做什么。我们需要建立自己的模板，然后让用户执行我们的my-cli去选择需要的模板。当读我们这篇文章的时候也许你还没有准备好项目模板，没关系，我们先在项目根目录建立一个templates文件夹，然后在templates文件夹下分别新建一个template-one和template-two的文件夹。然后在两个文件夹下执行 npm init 或者直接拷贝以下代码：

![](https://pic2.zhimg.com/v2-83951fe4b012a4a9cc68c8676b785921_1440w.jpg)

项目目录

```text
// 文件 template-one/package.json
{
  "name": "template-one",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "author": "",
  "license": "ISC"
}

// 文件 template-two/package.json
{
  "name": "template-two",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "author": "",
  "license": "ISC"
}
```

### 1、实现create

做好以上准备之后，我们就可以准备实现脚手架的create方法了。这里的话我们需要用到

commander：拥有完整的node.js命令行解决方案

fs-extra：封装了fs文件操作的方法，使用起来比fs更加简单

首先我们安装一下

```text
npm install commander fs-extra
```

然后将 bin/index.js 中的文件内容更新如下，我将很多需要了解的内容放在了备注里面，大家可以仔细阅读：

```text
#! /usr/bin/env node
// 我们以下的所有console.log都是为了方便验证我们的操作是否成功，脚手架搭建成功后大家自行删除
console.log('start cli');
// 引入commander，并初始化
const commander = require('commander');
const program = new commander.Command();
const fs = require('fs-extra'); // 传统fs复制文件目录需要加很多判断比较麻烦,fs-extra解决了这个问题

// 定义 create 命令
program
  .command('create') // 配置命令的名字
  .alias('init') // 命令的别名
  .description('创建一个项目') // 命令对应的描述
  .option('-f, --force', '如果文件存在就强行覆盖')
  .option('-l, --local-path <path>', '从本地下载模板') // 因为我们目前没有git仓库去储存，所以先通过本地来拉取模板
  .action(async (option1, option2) => {
    /**
     * 这里 action 参数的数量需要和我们定义的option数量一致
     * 比如我们现在定义了 -f 和 -l 两个 option，那我们就需要填写 option1 和 option2 两个参数
     * 假如只填写一个参数的话，执行my-cli create my-project -l 时，就会报错error: unknown option '-l'
     * 执行 my-cli create test -l D:\self\important\my-cli\templates\template-one
     * option1的内容为 { localPath: 'D:\\self\\important\\my-cli\\templates\\template-one' }
     */
    // 取 process.argv[3] 为项目文件夹名称，不清楚为什么的看一下下面的program.parse()的注释内容
    const projectName = process.argv[3];
    let path = option1.localPath;

    try {
      await fs.copySync(path, `./${projectName}`); // 直接将-l设置的路径复制过去
      console.log('模板复制成功');
    } catch (err) {
      console.error(err);
    }
  });

/**
 * 处理用户执行时输入的参数,默认值是process.argv
 * process.argv 是 nodejs 提供的属性
 * 比如我们执行 my-cli create my-project 命令时，process.argv 的值是下面这样一个数组:
 * ['D:\\nvm-noinstall\\v16.17.0\\node.exe', 'D:\\nvm-noinstall\\v16.17.0\\node_modules\\my-cli\\bin\\index.js', 'create',  'test']
 * 以下这行代码也可以写为 program.parse(process.argv);
 */
program.parse();
```

执行命令

```text
my-cli create test-project  -l D:\self\important\my-cli\templates\template-one
```

\-l 的目录大家根据自己的来，执行后根目录会多一个 test-project 的文件夹，里面的内容与template-one文件夹中的一致。

![](https://pic3.zhimg.com/v2-a59c90eb6146af6d91d5871f49f1d102_1440w.jpg)

![](https://pic4.zhimg.com/v2-3d81331b07cc8d1531bb863ba64487f5_1440w.jpg)

如果你的执行结果和我的一致，那么恭喜你，已经完成了脚手架的初步探索。

**2、增加模板选项**

我们其实很容易发现，我们上面的内容没有实现vue-cli一样的模板选择，直接指定了某一个文件夹复制，并且打印出来的日志很丑，不要急，我们现在进行优化。

要实现以上功能我们需要以下三个库，由于不停的版本迭代，现在这些库已经不支持require引入了，我们需要采用import的方式引入，在 pageage.json 文件中添加以支持该写法

```text
{
  ...
  "type": "module",
  ...
}
```

inquirer：命令行交互工具----[Inquirer.js](https://link.zhihu.com/?target=https%3A//github.com/SBoudrias/Inquirer.js)

chalk：命令行美化工具

ora：命令行 loading 效果------[ora](https://link.zhihu.com/?target=https%3A//github.com/sindresorhus/ora)

执行命令

```text
npm install inquirer chalk ora
```

将 bin/index.js 中的文件内容更新如下

```text
#! /usr/bin/env node
import chalk from 'chalk'; // 命令行美化工具
import ora from 'ora'; // 命令行 loading 效果
import inquirer from 'inquirer'; // 命令行交互工具
import fs from 'fs-extra'; // 传统fs复制文件目录需要加很多判断比较麻烦,fs-extra解决了这个问题
import path from 'path'; // 命令行交互工具
import { program } from 'commander'; // 引入commander

// 定义 create 命令
program
  .command('create') // 配置命令的名字
  .alias('init') // 命令的别名
  .description('创建一个项目') // 命令对应的描述
  .option('-f, --force', '如果文件存在就强行覆盖')
  .option('-l, --local-path <path>', '从本地下载模板') // 因为我们目前没有git仓库去储存，所以先通过本地来拉取模板
  .action(async (option1, option2) => {
    /**
     * 这里 action 参数的数量需要和我们定义的option数量一致
     * 比如我们现在定义了 -f 和 -l 两个 option，那我们就需要填写 option1 和 option2 两个参数
     * 假如只填写一个参数的话，执行my-cli create my-project -l 时，就会报错error: unknown option '-l'
     * 执行 my-cli create test -l D:\self\important\my-cli\templates
     * option1的内容为 { localPath: 'D:\\self\\important\\my-cli\\templates' }
     */
    // 取 process.argv[3] 为项目文件夹名称，不清楚为什么的看一下下面的program.parse()的注释内容
    const projectName = process.argv[3];

    try {
      // 利用inquirer与用户进行交互
      let { choose } = await inquirer.prompt([
        {
          name: 'choose', // 获取选择后的结果
          type: 'list',
          message: '请选择一个模板创建项目',
          choices: ['template-one', 'template-two'], // 模板选项列表
        },
      ]);
      const syncTemplate = ora('同步模板中....');
      syncTemplate.start();
      // 复制模板到目标目录
      await fs.copySync(
        path.resolve(option1.localPath, choose),
        `./${projectName}`
      );
      syncTemplate.succeed();

      console.log(
        chalk.green(chalk.blue.underline.bold(projectName) + ' 项目创建成功!')
      );
      console.log(`
          __      __   __     __       _ _ _
         /  |    /  |  | |   / /    ___| (_) |
        / /| |  / /| |  |_| /_/___ / __| | | |
       / /  | |/ /  | |   | |  ___| (__| | |_|
      /_/    |__/    |_|  |_|      |___|_|_(_)
    
      `);
    } catch (err) {
      console.error(err);
    }
  });

/**
 * 处理用户执行时输入的参数,默认值是process.argv
 * process.argv 是 nodejs 提供的属性
 * 比如我们执行 my-cli create my-project 命令时，process.argv 的值是下面这样一个数组:
 * ['D:\\nvm-noinstall\\v16.17.0\\node.exe', 'D:\\nvm-noinstall\\v16.17.0\\node_modules\\my-cli\\bin\\index.js', 'create',  'test']
 * 以下这行代码也可以写为 program.parse(process.argv);
 */
program.parse();
```

运行命令

```text
my-cli create test -l D:\self\important\my-cli\templates
```

运行结果如下图所示

![](https://pica.zhimg.com/v2-0eb2620f7d96a5f14d76ca52231d4266_1440w.jpg)

![](https://picx.zhimg.com/v2-7dd1a3286f4a166925c8f724107d2761_1440w.jpg)

可以看到我们已经得到了一个能选择项目模板，并且我们的命令行中的文案有了不同的颜色和样式。

### 3、修改脚手架代码，实现通用

我们以上的代码都还是在本地运行的，用户本地可不会有模板，就算有，用户也不一定能够知道模板的文件位置。我们接下来要做的事情就是将我们的代码上传到git仓库上，然后修改代码，使其无需填写 -l option

上传git仓库这个我就不赘述了，上传成功后我们需要用到 download-git-repo 来下载远程模板。首先我们安装一下

```text
npm install download-git-repo
```

将 bin/index.js 中的文件内容更新如下

```text
#! /usr/bin/env node
import chalk from 'chalk'; // 命令行美化工具
import ora from 'ora'; // 命令行 loading 效果
import inquirer from 'inquirer'; // 命令行交互工具
import { program } from 'commander'; // 引入commander
import download from 'download-git-repo';
// 定义 create 命令
program
  .command('create') // 配置命令的名字
  .alias('init') // 命令的别名
  .description('创建一个项目') // 命令对应的描述
  .option('-f, --force', '如果文件存在就强行覆盖')
  .option('-l, --local-path <path>', '从本地下载模板') // 因为我们目前没有git仓库去储存，所以先通过本地来拉取模板
  .action(async (option1, option2) => {
    /**
     * 这里 action 参数的数量需要和我们定义的option数量一致
     * 比如我们现在定义了 -f 和 -l 两个 option，那我们就需要填写 option1 和 option2 两个参数
     * 假如只填写一个参数的话，执行my-cli create my-project -l 时，就会报错error: unknown option '-l'
     * 执行 my-cli create test -l D:\self\important\my-cli\templates
     * option1的内容为 { localPath: 'D:\\self\\important\\my-cli\\templates' }
     */
    // 取 process.argv[3] 为项目文件夹名称，不清楚为什么的看一下下面的program.parse()的注释内容
    const projectName = process.argv[3];

    try {
      // 利用inquirer与用户进行交互
      let { choose } = await inquirer.prompt([
        {
          name: 'choose', // 获取选择后的结果
          type: 'list',
          message: '请选择一个模板创建项目',
          choices: ['template-one', 'template-two'], // 模板选项列表
        },
      ]);
      const syncTemplate = ora('同步模板中....');
      syncTemplate.start();
      // 复制模板到目标目录
      /**
       * 解释一下https://github.com:bingmada/my-cli#master 这个怎么写
       * 我的git clone地址为https://github.com/bingmada/my-cli.git
       * https://github.com + : + bingmada/my-cli + # + 分支名称 
       */
      download(
        'https://github.com:bingmada/my-cli#master',
        `./${projectName}`,
        {
          map: (file) => {
            file.path = file.path.replace(`templates\\${choose}`, '');
            return file;
          },
          filter: (file) => {
            return file.path.indexOf(`templates\\${choose}`) != -1;
          },
        },
        function (err) {
          if (err) {
            console.error(err);
            return;
          }
          syncTemplate.succeed();
          console.log(
            chalk.green(
              chalk.blue.underline.bold(projectName) + ' 项目创建成功!'
            )
          );
          console.log(`
              __      __   __     __       _ _ _
             /  |    /  |  | |   / /    ___| (_) |
            / /| |  / /| |  |_| /_/___ / __| | | |
           / /  | |/ /  | |   | |  ___| (__| | |_|
          /_/    |__/    |_|  |_|      |___|_|_(_)
        
          `);
        }
      );
    } catch (err) {
      console.error(err);
    }
  });

/**
 * 处理用户执行时输入的参数,默认值是process.argv
 * process.argv 是 nodejs 提供的属性
 * 比如我们执行 my-cli create my-project 命令时，process.argv 的值是下面这样一个数组:
 * ['D:\\nvm-noinstall\\v16.17.0\\node.exe', 'D:\\nvm-noinstall\\v16.17.0\\node_modules\\my-cli\\bin\\index.js', 'create',  'test']
 * 以下这行代码也可以写为 program.parse(process.argv);
 */
program.parse();
```

  

接下来我们只需要简单的执行即可

```text
my-cli create test-project
```

![](https://pic1.zhimg.com/v2-4e29edb67f83389be9b58c435a9c28e6_1440w.jpg)

### 4、添加help

由于commander已经提供了help，如下图所示

![](https://picx.zhimg.com/v2-4e4ef68b49bfa443f54a7bad5f8835fd_1440w.jpg)

我们只需要简单的在 program.parse()前面增加以下内容即可

```text
// 监听用户输入--help
program.on('--help', function () {
  console.log('\nExamples:')
  console.log(`my-cli create <project-name>`)
})
```

至此我们已经完成了一个脚手架的初步开发，只需要将其推送到npm上即可。

当前脚手架的功能还过于单一，比如input交互，是否交互等，后续有时间我会继续更新。

编辑于 2024-04-25 09:42・浙江

[前端开发](//www.zhihu.com/topic/19550901)

[脚手架](//www.zhihu.com/topic/20387021)

[前端工程化](//www.zhihu.com/topic/20010840)

​赞同 48​​8 条评论

​分享

​喜欢​收藏​申请转载

​